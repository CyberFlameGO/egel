.\" generated with Ronn/v0.7.3
.\" http://github.com/rtomayko/ronn/tree/0.7.3
.
.TH "EGEL" "1" "September 2021" "" ""
.
.SH "NAME"
\fBegel\fR \- an interpreted, interactive, eager\-combinator language
.
.SH "SYNOPSIS"
\fBegel\fR [\fB\-\fR] [\fB\-I\fR \fIpath] [\fI\fR\fRfile\fI] \fBegel\fR [\fB\-I\fR\fRpath] \fB\-e\fR \fIcommand\fR \fBegel\fR [\fB\-h\fR|\fB\-\-help\fR|\fB\-v\fR|\fB\-\-version\fR]
.
.SH "DESCRIPTION"
Egel is an interpreted, interactive, eager\-combinator programming language that combines remarkable power with very clear syntax\.
.
.P
A short tutorial as in introduction into the language is given below\.
.
.P
Egel\'s basic power can be extended with your own modules written in C++\. Those modules are dynamically loaded\.
.
.SH "OPTIONS"
.
.TP
\-h, \-\-help
Prints brief usage information, may list debug options\.
.
.TP
\-, \-\-interact
Enter interactive mode unconditionally\.
.
.TP
\-e, \-\-eval \fIcommand\fR
Evaluate the given command\.
.
.TP
\-v, \-\-version
Prints the current version number\.
.
.TP
\-I, \-\-include \fIpath\fR
Add an include path\.
.
.SH "TUTORIAL"
Below, a short introduction to the Egel language is given\.
.
.SS "Expressions"
.
.TP
Basic primitive types are integers, floats, unicode characters, and unicode strings\.
\fB0 1 2\fR , \fB0\.0 3\.14 \-1\.2\fR , \fB\'a\' \'âˆ€\'\fR , or \fB"Hello World!"\fR
.
.TP
All constants compose\.
\fB(0 1)\fR is just as legal as \fB(cons \'a\' nil)\fR
.
.TP
Rewriting is done with the pattern\-matching abstraction, uppercase letters denote variables\.
\fB[ X \-> X ]\fR , \fB[ (cons HEAD TAIL) \-> HEAD ]\fR,
.
.TP
The abstraction consists of a number of matches, it may be variadic without penalty\.
\fB[ X Y \-> 2 | X \-> 1 | \-> 0]\fR
.
.TP
Patterns may hold rudimentary type matches\.
\fB[ I::int \-> "an int" | C::cons \-> "a cons" ]\fR
.
.TP
Let expressions allow to assign values to intermediateries\.
\fBlet X = 1 + 2 in X * X\fR
.
.TP
Exception handling is supported, any value may be thrown and caught\.
\fBtry 1 + throw "failure" catch [ EXC \-> print EXC ]\fR
.
.TP
Parallell programming is achieved through the \fBpar\fR and \fBproc\fR abstractions\.
.
.TP
A \fBpar\fR starts two computations in parallel and returns a tuple of both values after both complete\.
\fB[ (X, Y) \-> X + Y ] (par [ _ \-> \fIcomputation0\fR ] [ _ \-> \fIcomputation1\fR ])\fR
.
.P
The process abstraction is not discussed here\.
.
.TP
Formatting strings is handled with the \fBformat\fR combinator, see \fIhttps://fmt\.dev/\fR\.
\fBprint (format "Hello {}" "world")\fR
.
.SS "Modules"
A module is a series of combinator declarations possibly encapsulated in a namespace\. All combinators are named lowercase, there is some provisional support for unicode\. Modules may import each other\. The \fBmain\fR combinator of the top module drives all computation when present\.
.
.P
Tying it all together:
.
.IP "" 4
.
.nf

# A parallel fibonnaci implementation\.

import "prelude\.eg"

namespace Fibonnaci (
  using System

  def fib =
    [ 0 \-> 0
    | 1 \-> 1
    | N \-> fib (N\- 2) + fib (N\- 1) ]

  def pfib =
    [ 0 \-> 0
    | 1 \-> 1
    | X \-> [ (F0, F1) \-> F0 + F1 ]
           (par [Y \-> pfib (X \- 1) ] [Z\-> pfib (X \- 2)]) ]

)

using System

def main = Fibonnaci:pfib (3+2)
.
.fi
.
.IP "" 0
.
.SH "FILES"
The following files should be in the \fBEGEL_INCLUDE\fR directory\.
.
.TP
\fIprelude\.eg\fR
The standard Egel prelude\.
.
.TP
\fIio\.ego\fR \fIregex\.ego\fR
Standard input/output, regexes\.
.
.SH "ENVIRONMENT"
.
.TP
\fBEGEL_INCLUDE\fR
The default dedication if none is given\.
.
.TP
\fBEGEL_PS0\fR
The prompt given by the interpreter in interactive mode\.
.
.SH "BUGS"
See GitHub Issues: \fIhttps://github\.com/egel\-lang/egel/issues\fR
.
.SH "AUTHOR"
M\.C\.A\. (Marco) Devillers \fImarco\.devillers@gmail\.com\fR
.
.SH "SEE ALSO"
\fBc++(1)\fR
